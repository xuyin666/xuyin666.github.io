(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{555:function(t,r,v){"use strict";v.r(r);var _=v(3),n=Object(_.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"题目描述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[t._v("#")]),t._v(" 题目描述")]),t._v(" "),v("p",[t._v("给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。")]),t._v(" "),v("p",[t._v("函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。")]),t._v(" "),v("p",[t._v("你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。")]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"题目理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#题目理解"}},[t._v("#")]),t._v(" 题目理解")]),t._v(" "),v("p",[t._v("对于我而言 我的理解是")]),t._v(" "),v("ul",[v("li",[t._v("我们接收一个数组 结果也得返回一个数组")]),t._v(" "),v("li",[t._v("我们接收到的数组是升序排列的")]),t._v(" "),v("li",[t._v("返回数组的下标得从1开始计数（意味着返回时的index得加一）")]),t._v(" "),v("li",[t._v("其次"),v("strong",[t._v("不可以")]),t._v("使用重复相同的元素")]),t._v(" "),v("li",[t._v("每个输入一定有着一个答案")])]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"解题方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解题方法"}},[t._v("#")]),t._v(" 解题方法")]),t._v(" "),v("p",[t._v("这道题我的解题办法是使用双指针")]),t._v(" "),v("p",[t._v("为什么选择双指针，这是因为我看到的最优解决办法，同时我希望锻炼这个算法思想。")]),t._v(" "),v("p",[t._v("双指针 顾名思义我们可以有两个指针。 在这里我们的方法是一个指针指向数组头部，另一个指针指向数组尾部。")]),t._v(" "),v("p",[t._v("例如 i 指向头部，j 指向尾部")]),t._v(" "),v("p",[t._v("我的做法是 让i往尾部走 j往头部走 直到他们相遇或者我们找到了合适的和 不然就不让他们停下")]),t._v(" "),v("p",[t._v("因为每个输入一定有一个解 所以在i，j两个指针覆盖所有数组元素前 我们一定能有一个解")]),t._v(" "),v("h3",{attrs:{id:"问题1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题1"}},[t._v("#")]),t._v(" 问题1")]),t._v(" "),v("p",[t._v("i，j 会在什么时候停下 这个临界值怎么取 ？i <= j 还是 i < j ？")]),t._v(" "),v("p",[t._v("答案是 只要i < j就继续")]),t._v(" "),v("p",[t._v("因为如果i==j 那么我们正在使用相同的元素 有可能返回相同的元素 不行")]),t._v(" "),v("h3",{attrs:{id:"问题2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题2"}},[t._v("#")]),t._v(" 问题2")]),t._v(" "),v("p",[t._v("在循环里 i，j如何变化 ？")]),t._v(" "),v("p",[t._v("我的理解是 每次操作检查进行检查")]),t._v(" "),v("ul",[v("li",[t._v("如果两数和刚刚好 就直接返回")]),t._v(" "),v("li",[t._v("如果两数和较大 就让j-- 因为需要让和减小 就让j往前走 因为这是个递增数组")]),t._v(" "),v("li",[t._v("如果两数和较小 就让i++ 因为需要让和增大 就让i往后退 因为这是个递增数组")])]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"解题代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解题代码"}},[t._v("#")]),t._v(" 解题代码")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("    public int[] twoSum(int[] numbers, int target) {\n        int[] sumArr = new int[2];\n        int i = 0;\n        int j = numbers.length - 1;\n        while (i < j) {\n            if (numbers[i] + numbers[j] == target) {\n                // 当两数的和恰好为我们目标值\n                sumArr[0] = i + 1;\n                sumArr[1] = j + 1;\n                return sumArr;\n            } else if (numbers[i] + numbers[j] > target) {\n                // 当两数的和比我们的目标值大\n                j--;\n            } else {\n                // 当两数的和比我们的目标值小\n                i++;\n            }\n        }\n        return null ;\n    }\n")])])])])}),[],!1,null,null,null);r.default=n.exports}}]);